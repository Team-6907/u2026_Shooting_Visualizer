<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Shoot-on-Move Visualizer</title>
    <link rel="icon" type="image/png" href="assets/rebuilt_logo.png" />
    <link rel="shortcut icon" type="image/png" href="assets/rebuilt_logo.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,600&family=IBM+Plex+Mono:wght@500&family=IBM+Plex+Sans:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #f2f4f7;
        --panel: #ffffff;
        --ink: #1b1f24;
        --muted: #5f6c7b;
        --accent: #ee6c4d;
        --goal: #3d5a80;
        --velocity: #2a9d8f;
        --outline: rgba(27, 31, 36, 0.1);
        --shadow: rgba(20, 26, 36, 0.08);
      }

      * { box-sizing: border-box; }

      body {
        margin: 0;
        font-family: "IBM Plex Sans", system-ui, sans-serif;
        color: var(--ink);
        background: var(--bg);
        overflow: hidden;
      }

      .app {
        display: grid;
        grid-template-columns: 1fr 320px;
        height: 100vh;
      }

      #canvas-container {
        position: relative;
        background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
        outline: none;
      }

      #canvas-container canvas {
        display: block;
      }

      .hud {
        position: absolute;
        top: 20px;
        left: 20px;
        color: #fff;
        font-size: 12px;
        background: rgba(0,0,0,0.6);
        padding: 12px 16px;
        border-radius: 8px;
        font-family: "IBM Plex Mono", monospace;
        pointer-events: none;
      }

      .hud h3 {
        margin: 0 0 8px;
        font-family: "Fraunces", serif;
        font-size: 18px;
      }

      .hud .keys {
        margin-top: 12px;
        padding-top: 8px;
        border-top: 1px solid rgba(255,255,255,0.2);
        font-size: 11px;
        line-height: 1.6;
      }

      .hud kbd {
        background: rgba(255,255,255,0.15);
        padding: 2px 6px;
        border-radius: 4px;
        font-family: inherit;
      }

      .controls-panel {
        background: var(--panel);
        padding: 20px;
        overflow-y: auto;
        border-left: 1px solid var(--outline);
      }

      .controls-panel h2 {
        font-family: "Fraunces", serif;
        font-size: 24px;
        margin: 0 0 16px;
      }

      .control-group {
        display: grid;
        gap: 10px;
        padding: 12px;
        border-radius: 14px;
        border: 1px solid var(--outline);
        background: #fbfcfe;
        margin-bottom: 12px;
      }

      .control-group label {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: var(--muted);
      }

      .control-row {
        display: grid;
        grid-template-columns: 1fr 70px;
        gap: 8px;
        align-items: center;
      }

      input[type="range"] {
        width: 100%;
        accent-color: var(--accent);
      }

      input[type="number"] {
        width: 100%;
        border-radius: 8px;
        border: 1px solid rgba(27, 31, 36, 0.2);
        padding: 4px 6px;
        font-size: 12px;
        font-family: "IBM Plex Mono", monospace;
      }

      .metrics {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-top: 16px;
      }

      .metric {
        padding: 10px;
        border-radius: 10px;
        border: 1px solid var(--outline);
        background: #fff;
      }

      .metric .label {
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        color: var(--muted);
        margin-bottom: 4px;
      }

      .metric .value {
        font-family: "IBM Plex Mono", monospace;
        font-size: 16px;
      }

      .metric .value.ok { color: #2a9d8f; }
      .metric .value.warn { color: #c1121f; }

      .toggle {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
      }

      .helper {
        font-size: 11px;
        color: var(--muted);
      }

      .reset-button {
        border: 1px solid var(--outline);
        border-radius: 10px;
        background: #fff;
        color: var(--ink);
        padding: 8px 10px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }

      .reset-button:hover {
        transform: translateY(-1px);
        box-shadow: 0 6px 16px var(--shadow);
      }

      .camera-hint {
        position: absolute;
        bottom: 20px;
        left: 20px;
        color: rgba(255,255,255,0.6);
        font-size: 11px;
        pointer-events: none;
      }

      @media (max-width: 900px) {
        .app {
          grid-template-columns: 1fr;
          grid-template-rows: 60vh 1fr;
        }
        .controls-panel {
          border-left: none;
          border-top: 1px solid var(--outline);
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div id="canvas-container" tabindex="0">
        <div class="hud">
          <h3>åŠ¨æ€å°„çƒå¯è§†åŒ–</h3>
          <div class="keys">
            <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> ç§»åŠ¨ <kbd>Space</kbd> åœ
          </div>
          <div style="margin-top: 8px; font-size: 10px; line-height: 1.5;">
            <span style="color: #ee6c4d;">â”€</span> ç„å‡†
            <span style="color: #ffb703;">â—</span> è™šæ‹Ÿç›®æ ‡
            <span style="color: #2a9d8f;">â—</span> è½ç‚¹<br>
            <span style="color: #ee6c4d;">âŒ’</span> å¼¹é“
            <span style="color: #2a9d8f;">â†’</span> é€Ÿåº¦
          </div>
        </div>
        <div class="camera-hint">æ‹–æ‹½æ—‹è½¬ Â· æ»šè½®ç¼©æ”¾ Â· ç‚¹å‡»å¯ç”¨é”®ç›˜</div>
      </div>

      <aside class="controls-panel">
        <h2>æ§åˆ¶</h2>

        <div class="control-group">
          <label>ä½ç½® X/Y (m)</label>
          <div class="control-row" data-key="robotX">
            <input type="range" min="0" max="16.54" step="0.01" value="2.0" />
            <input type="number" step="0.01" value="2.0" />
          </div>
          <div class="control-row" data-key="robotY">
            <input type="range" min="0" max="8.07" step="0.01" value="4.035" />
            <input type="number" step="0.01" value="4.035" />
          </div>
        </div>

        <div class="control-group">
          <label>æœ€å¤§é€Ÿåº¦ (m/s)</label>
          <div class="control-row" data-key="maxLinearSpeed">
            <input type="range" min="0.5" max="6.86" step="0.1" value="2.0" />
            <input type="number" step="0.1" value="2.0" />
          </div>
        </div>

        <div class="control-group">
          <label>æœ€å¤§åŠ é€Ÿåº¦ (m/sÂ²)</label>
          <div class="control-row" data-key="maxAcceleration">
            <input type="range" min="0.5" max="6.87" step="0.1" value="3.0" />
            <input type="number" step="0.1" value="3.0" />
          </div>
        </div>

        <div class="control-group">
          <label class="toggle">
            <input type="checkbox" id="shootOnMove" checked />
            åŠ¨æ€è¡¥å¿
          </label>
        </div>

        <div class="control-group" style="border-top: 1px solid rgba(255,255,255,0.2); padding-top: 12px; margin-top: 8px;">
          <label style="font-weight: bold; color: #f4a261;">âš™ï¸ æœºæ„å‚æ•°</label>

          <label>å‘å°„é«˜åº¦ (m)</label>
          <div class="control-row" data-key="launcherHeight">
            <input type="range" min="0.2" max="1.0" step="0.05" value="0.5" />
            <input type="number" step="0.05" value="0.5" />
          </div>

          <label>Hood æœ€å°è§’ (Â°)</label>
          <div class="control-row" data-key="minHoodAngle">
            <input type="range" min="20" max="80" step="1" value="45" />
            <input type="number" step="1" value="45" />
          </div>

          <label>Hood æœ€å¤§è§’ (Â°)</label>
          <div class="control-row" data-key="maxHoodAngle">
            <input type="range" min="50" max="90" step="1" value="90" />
            <input type="number" step="1" value="90" />
          </div>

          <label>æœ€å°å…¥å°„è§’ (Â°)</label>
          <div class="control-row" data-key="minEntryAngle">
            <input type="range" min="15" max="60" step="5" value="45" />
            <input type="number" step="5" value="45" />
          </div>

          <label>é£è½®æœ€é«˜é€Ÿ (m/s)</label>
          <div class="control-row" data-key="maxFlywheelSpeed">
            <input type="range" min="10" max="45" step="1" value="25" />
            <input type="number" step="1" value="25" />
          </div>

          <label>å‘å°„å£åç§» X (m)</label>
          <div class="control-row" data-key="launcherOffsetX">
            <input type="range" min="-1.0" max="1.0" step="0.01" value="-0.53" />
            <input type="number" step="0.01" value="-0.53" />
          </div>

          <label>å‘å°„å£åç§» Y (m)</label>
          <div class="control-row" data-key="launcherOffsetY">
            <input type="range" min="-1.0" max="1.0" step="0.01" value="0.05" />
            <input type="number" step="0.01" value="0.05" />
          </div>

          <label>å‘å°„å£åç§» Z (m)</label>
          <div class="control-row" data-key="launcherOffsetZ">
            <input type="range" min="0.0" max="1.5" step="0.01" value="0.03" />
            <input type="number" step="0.01" value="0.03" />
          </div>
        </div>

        <div class="control-group">
          <label style="font-weight: bold; color: #2a9d8f;">ğŸ¯ ç›®æ ‡å°„å‡»ç‚¹ (m)</label>

          <label>ç›®æ ‡ X</label>
          <div class="control-row" data-key="targetX">
            <input type="range" min="0" max="16.54" step="0.01" value="5.58" />
            <input type="number" step="0.01" value="5.58" />
          </div>

          <label>ç›®æ ‡ Y</label>
          <div class="control-row" data-key="targetY">
            <input type="range" min="0" max="8.07" step="0.01" value="3.35" />
            <input type="number" step="0.01" value="3.35" />
          </div>

          <label>ç›®æ ‡ Z</label>
          <div class="control-row" data-key="targetZ">
            <input type="range" min="0.5" max="3.0" step="0.01" value="1.23" />
            <input type="number" step="0.01" value="1.23" />
          </div>

          <button class="reset-button" id="resetTarget" type="button">æ¢å¤é»˜è®¤</button>
        </div>

        <div class="metrics">
          <div class="metric">
            <div class="label">è·ç¦»</div>
            <div class="value" id="metricRange">0.00</div>
          </div>
          <div class="metric">
            <div class="label">é£è½®</div>
            <div class="value" id="metricFlywheel">0.0</div>
          </div>
          <div class="metric">
            <div class="label">Hood</div>
            <div class="value" id="metricHood">0.0</div>
          </div>
          <div class="metric">
            <div class="label">å…¥å°„è§’</div>
            <div class="value" id="metricEntry">0.0</div>
          </div>
          <div class="metric">
            <div class="label">å‘½ä¸­</div>
            <div class="value" id="metricOnTarget">å¦</div>
          </div>
        </div>
      </aside>
    </div>

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
    </script>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

      // ===== å¸¸é‡å®šä¹‰ =====
      const FIELD_LENGTH = 16.54;
      const FIELD_WIDTH = 8.07;
      const GRAVITY = 9.81;

      const BALL_DIAMETER = 0.15;
      const BALL_RADIUS = BALL_DIAMETER / 2;
      const BALL_MASS = 0.2;
      const AIR_DENSITY = 1.225;
      const BALL_CD = 0.47;
      const BALL_AREA = Math.PI * BALL_RADIUS * BALL_RADIUS;
      const DRAG_K = 0.5 * AIR_DENSITY * BALL_CD * BALL_AREA / BALL_MASS;
      const SIM_DT = 1 / 240;
      const MAX_SIM_TIME = 4.0;
      const TRAJ_DT = 1 / 120;
      const TRAJ_MAX_TIME = 3.5;
      const SHOT_INTERVAL = 0.25;
      const SHOT_LIFETIME = 3.2;
      const MAX_SHOTS = 36;

      const DEFAULT_TARGET_X = 5.58;
      const DEFAULT_TARGET_Y = 3.35;
      const DEFAULT_TARGET_HEIGHT = 1.23;
      const HUB_OPENING_SIZE = 1.06;

      // ===== çŠ¶æ€å˜é‡ =====
      const state = {
        // æœºå™¨äººä½ç½®å’Œè¿åŠ¨
        robotX: 2.0,
        robotY: 4.035,
        robotVx: 0,
        robotVy: 0,
        chassisHeading: 0,
        maxLinearSpeed: 2.0,
        maxAcceleration: 3.0,
        shootOnMove: true,
        // æœºæ¢°å‚æ•° (å¯åœ¨ UI è°ƒæ•´)
        launcherHeight: 0.5,    // å‘å°„é«˜åº¦ (m)
        minHoodAngle: 45,       // Hood æœ€å°è§’åº¦ (deg)
        maxHoodAngle: 90,       // Hood æœ€å¤§è§’åº¦ (deg)
        minEntryAngle: 45,      // æœ€å°ä¸‹è½è§’åº¦ (deg)
        maxFlywheelSpeed: 25,   // é£è½®æœ€é«˜é€Ÿåº¦ (m/s)
        targetX: DEFAULT_TARGET_X,
        targetY: DEFAULT_TARGET_Y,
        targetZ: DEFAULT_TARGET_HEIGHT,
        launcherOffsetX: -0.53,
        launcherOffsetY: 0.05,
        launcherOffsetZ: 0.03,
      };

      const keys = { w: false, a: false, s: false, d: false };

      // ===== DOM å¼•ç”¨ =====
      const metrics = {
        range: document.getElementById("metricRange"),
        flywheel: document.getElementById("metricFlywheel"),
        hood: document.getElementById("metricHood"),
        entry: document.getElementById("metricEntry"),
        onTarget: document.getElementById("metricOnTarget"),
      };

      // ===== ç‰©ç†è®¡ç®—å‡½æ•° =====

      // HUB åº•åº§åŠå®½ (çƒåˆ°è¾¾è¾¹ç¼˜æ—¶å¿…é¡»æ¸…ç©ºè¾¹ç¼˜é«˜åº¦)
      const HUB_HALF_WIDTH = 0.6;

      function getTargetHeight() {
        return state.targetZ + BALL_RADIUS;
      }

      function getLauncherWorldOffset() {
        const cosH = Math.cos(state.chassisHeading);
        const sinH = Math.sin(state.chassisHeading);
        const localX = state.launcherOffsetX;
        const localY = state.launcherOffsetY;
        return {
          x: cosH * localX - sinH * localY,
          y: sinH * localX + cosH * localY,
          z: state.launcherOffsetZ,
        };
      }

      function sampleAtX(prev, curr, targetX) {
        const dx = curr.x - prev.x;
        const ratio = dx !== 0 ? (targetX - prev.x) / dx : 0;
        return {
          t: prev.t + (curr.t - prev.t) * ratio,
          x: targetX,
          z: prev.z + (curr.z - prev.z) * ratio,
          vx: prev.vx + (curr.vx - prev.vx) * ratio,
          vz: prev.vz + (curr.vz - prev.vz) * ratio,
        };
      }

      function sampleAtZ(prev, curr, targetZ) {
        const dz = curr.z - prev.z;
        if (Math.abs(dz) < 1e-6) return null;
        const ratio = (targetZ - prev.z) / dz;
        return {
          t: prev.t + (curr.t - prev.t) * ratio,
          x: prev.x + (curr.x - prev.x) * ratio,
          z: targetZ,
          vx: prev.vx + (curr.vx - prev.vx) * ratio,
          vz: prev.vz + (curr.vz - prev.vz) * ratio,
        };
      }

      function simulateShotToRange(angle, speed, targetRange, edgeRange) {
        const cosA = Math.cos(angle);
        const sinA = Math.sin(angle);
        let vx = speed * cosA;
        let vz = speed * sinA;
        let x = 0;
        let z = 0;
        let t = 0;
        let edgeSample = null;
        let targetSample = null;
        let prev = { x, z, vx, vz, t };

        const maxX = Math.max(targetRange, edgeRange, 0) + 1.0;

        while (t < MAX_SIM_TIME && z > -2 && x <= maxX) {
          const v = Math.hypot(vx, vz);
          const ax = -DRAG_K * v * vx;
          const az = -GRAVITY - DRAG_K * v * vz;

          vx += ax * SIM_DT;
          vz += az * SIM_DT;
          x += vx * SIM_DT;
          z += vz * SIM_DT;
          t += SIM_DT;

          const curr = { x, z, vx, vz, t };

          if (!edgeSample && edgeRange > 0 && x >= edgeRange) {
            edgeSample = sampleAtX(prev, curr, edgeRange);
          }

          if (x >= targetRange) {
            targetSample = sampleAtX(prev, curr, targetRange);
            break;
          }

          if (vx <= 0 && x < targetRange) {
            break;
          }

          prev = curr;
        }

        return {
          reached: !!targetSample,
          timeAtRange: targetSample ? targetSample.t : Infinity,
          zAtRange: targetSample ? targetSample.z : -Infinity,
          vxAtRange: targetSample ? targetSample.vx : 0,
          vzAtRange: targetSample ? targetSample.vz : 0,
          zAtEdge: edgeSample ? edgeSample.z : -Infinity,
          timeAtEdge: edgeSample ? edgeSample.t : Infinity,
        };
      }

      function solveSpeedForAngle(angle, targetRange, deltaH, edgeRange, maxSpeed) {
        const minSpeed = 0.5;
        let low = minSpeed;
        let high = maxSpeed;
        let lowSim = simulateShotToRange(angle, low, targetRange, edgeRange);
        let highSim = simulateShotToRange(angle, high, targetRange, edgeRange);

        if (!highSim.reached || highSim.zAtRange < deltaH) return null;

        if (lowSim.reached && lowSim.zAtRange > deltaH) {
          for (let i = 0; i < 6 && low > 0.1 && lowSim.zAtRange > deltaH; i++) {
            low *= 0.5;
            lowSim = simulateShotToRange(angle, low, targetRange, edgeRange);
          }
        }

        for (let i = 0; i < 10; i++) {
          const mid = (low + high) / 2;
          const midSim = simulateShotToRange(angle, mid, targetRange, edgeRange);
          const midZ = midSim.reached ? midSim.zAtRange : -Infinity;
          if (midZ >= deltaH) {
            high = mid;
            highSim = midSim;
          } else {
            low = mid;
            lowSim = midSim;
          }
        }

        return { speed: high, sim: highSim };
      }

      function simulateShotToHeight(vHorizontal, vz0, targetHeight) {
        let vx = vHorizontal;
        let vz = vz0;
        let x = 0;
        let z = 0;
        let t = 0;
        let prev = { x, z, vx, vz, t };
        let reachedUp = false;

        while (t < MAX_SIM_TIME && z > -2) {
          const v = Math.hypot(vx, vz);
          const ax = -DRAG_K * v * vx;
          const az = -GRAVITY - DRAG_K * v * vz;

          vx += ax * SIM_DT;
          vz += az * SIM_DT;
          x += vx * SIM_DT;
          z += vz * SIM_DT;
          t += SIM_DT;

          const curr = { x, z, vx, vz, t };

          if (!reachedUp && z >= targetHeight) {
            reachedUp = true;
          }

          if (reachedUp && z <= targetHeight) {
            const sample = sampleAtZ(prev, curr, targetHeight);
            if (sample) {
              return {
                reached: true,
                time: sample.t,
                x: sample.x,
                vx: sample.vx,
                vz: sample.vz,
              };
            }
            break;
          }

          if (vx <= 0 && !reachedUp) {
            break;
          }

          prev = curr;
        }

        return { reached: false };
      }

      /**
       * åœ¨çº¦æŸèŒƒå›´å†…æ‰¾åˆ°æœ€ä¼˜ Hood è§’åº¦
       * çº¦æŸ: è¾¹ç¼˜é«˜åº¦>HUB, ä¸‹é™é˜¶æ®µ, å…¥å°„è§’å¤Ÿé™¡, é£è½®é€Ÿåº¦â‰¤æœ€å¤§å€¼
       */
      function findOptimalHoodAngle(range, deltaH, targetHeight) {
        const STEP = 0.5 * Math.PI / 180;

        // ä» state è¯»å–å¯è°ƒå‚æ•°
        const launcherHeight = state.launcherHeight;
        const minHoodAngle = state.minHoodAngle * Math.PI / 180;
        const maxHoodAngle = state.maxHoodAngle * Math.PI / 180;
        const minEntryAngle = state.minEntryAngle * Math.PI / 180;
        const maxFlywheelSpeed = state.maxFlywheelSpeed;

        const distToHubEdge = Math.max(range - HUB_HALF_WIDTH - BALL_RADIUS, 0.05);

        let bestAngle = minHoodAngle;
        let minSpeed = Infinity;
        let foundValid = false;
        let bestEntryAngle = 0;
        let bestHeightAtEdge = 0;
        let bestTimeOfFlight = 0;

        // å¤‡é€‰æ–¹æ¡ˆ
        let fallbackAngle = minHoodAngle;
        let fallbackSpeed = Infinity;
        let fallbackEntryAngle = 0;
        let fallbackHeightAtEdge = 0;
        let fallbackTimeOfFlight = 0;
        let fallbackLevel = 0;

        for (let angle = minHoodAngle; angle <= maxHoodAngle; angle += STEP) {
          const solved = solveSpeedForAngle(angle, range, deltaH, distToHubEdge, maxFlywheelSpeed);
          if (!solved) continue;
          const speed = solved.speed;
          const sim = solved.sim;

          const heightAtEdge = sim.zAtEdge + launcherHeight;
          const clearsHub = heightAtEdge > targetHeight;

          if (!clearsHub) {
            if (fallbackLevel < 1 || (fallbackLevel === 1 && speed < fallbackSpeed)) {
              fallbackLevel = 1;
              fallbackSpeed = speed;
              fallbackAngle = angle;
              fallbackHeightAtEdge = heightAtEdge;
              fallbackEntryAngle = 0;
              fallbackTimeOfFlight = sim.timeAtRange;
            }
            continue;
          }

          const isDescending = sim.vzAtRange < 0;

          if (!isDescending) {
            if (fallbackLevel < 2 || (fallbackLevel === 2 && speed < fallbackSpeed)) {
              fallbackLevel = 2;
              fallbackSpeed = speed;
              fallbackAngle = angle;
              fallbackHeightAtEdge = heightAtEdge;
              fallbackEntryAngle = 0;
              fallbackTimeOfFlight = sim.timeAtRange;
            }
            continue;
          }

          const entryAngleRad = Math.atan2(-sim.vzAtRange, Math.max(sim.vxAtRange, 0.01));
          const entryAngleDeg = entryAngleRad * 180 / Math.PI;
          const isSteepEnough = entryAngleRad >= minEntryAngle;

          if (!isSteepEnough) {
            if (fallbackLevel < 3 || (fallbackLevel === 3 && speed < fallbackSpeed)) {
              fallbackLevel = 3;
              fallbackSpeed = speed;
              fallbackAngle = angle;
              fallbackHeightAtEdge = heightAtEdge;
              fallbackEntryAngle = entryAngleDeg;
              fallbackTimeOfFlight = sim.timeAtRange;
            }
            continue;
          }

          if (!foundValid || speed < minSpeed) {
            foundValid = true;
            minSpeed = speed;
            bestAngle = angle;
            bestEntryAngle = entryAngleDeg;
            bestHeightAtEdge = heightAtEdge;
            bestTimeOfFlight = sim.timeAtRange;
          }
        }

        if (foundValid) {
          return {
            angle: bestAngle,
            speed: minSpeed,
            heightAtEdge: bestHeightAtEdge,
            clearsHub: true,
            isDescending: true,
            isSteepEnough: true,
            entryAngleDeg: bestEntryAngle,
            timeOfFlight: bestTimeOfFlight,
            isValid: true
          };
        }

        return {
          angle: fallbackAngle,
          speed: fallbackSpeed,
          heightAtEdge: fallbackHeightAtEdge,
          clearsHub: fallbackLevel >= 2,
          isDescending: fallbackLevel >= 3,
          isSteepEnough: false,
          entryAngleDeg: fallbackEntryAngle,
          timeOfFlight: fallbackTimeOfFlight,
          isValid: false
        };
      }

      /**
       * ç”Ÿæˆ HUB å…­è¾¹å½¢é¡¶ç‚¹
       */
      function getHubHexPoints(openingSize, centerX, centerY) {
        const apothem = openingSize / 2;
        const radius = apothem / Math.cos(Math.PI / 6);
        const points = [];
        for (let i = 0; i < 6; i++) {
          const angle = (i * Math.PI) / 3 - Math.PI / 6;
          points.push({
            x: centerX + radius * Math.cos(angle),
            y: centerY + radius * Math.sin(angle),
          });
        }
        return points;
      }

      /**
       * æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨å¤šè¾¹å½¢å†…
       */
      function pointInPolygon(point, polygon) {
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
          const xi = polygon[i].x, yi = polygon[i].y;
          const xj = polygon[j].x, yj = polygon[j].y;
          const intersect = yi > point.y !== yj > point.y &&
            point.x < ((xj - xi) * (point.y - yi)) / (yj - yi) + xi;
          if (intersect) inside = !inside;
        }
        return inside;
      }

      const SCORING_OPENING_SIZE = Math.max(HUB_OPENING_SIZE - 2 * BALL_RADIUS, 0.1);

      /**
       * æ ¸å¿ƒè®¡ç®—å‡½æ•°ï¼šè®¡ç®—å°„çƒè§£å†³æ–¹æ¡ˆ
       */
      function computeShootingSolution() {
        const { robotX, robotY, robotVx, robotVy, shootOnMove } = state;
        const targetX = state.targetX;
        const targetY = state.targetY;
        const targetHeight = getTargetHeight();
        const launcherOffset = getLauncherWorldOffset();
        const launcherX = robotX + launcherOffset.x;
        const launcherY = robotY + launcherOffset.y;

        // Step 1: åŸºç¡€å‡ ä½•
        const dx = targetX - launcherX;
        const dy = targetY - launcherY;
        const range = Math.hypot(dx, dy);
        const goalAngle = Math.atan2(dy, dx);
        const deltaH = targetHeight - (state.launcherHeight + launcherOffset.z);

        // Step 2: åˆ†è§£æœºå™¨äººé€Ÿåº¦ä¸ºå¾„å‘/åˆ‡å‘ (å€Ÿé‰´ Team 254)
        const cosG = Math.cos(goalAngle);
        const sinG = Math.sin(goalAngle);
        const radialV = robotVx * cosG + robotVy * sinG;      // æœå‘ç›®æ ‡
        const tangentialV = -robotVx * sinG + robotVy * cosG; // å‚ç›´äºç›®æ ‡æ–¹å‘

        // Step 3: è¿­ä»£æ±‚è§£
        let timeOfFlight = 0.6;
        let effectiveRange = range;
        let effectiveShotSpeed = range / timeOfFlight;
        let hoodAngle = 60 * Math.PI / 180;
        let flywheelSpeed = 10;
        let isValid = false;
        let clearsHub = false;      // çƒæ˜¯å¦èƒ½è¶Šè¿‡ HUB è¾¹ç¼˜
        let heightAtEdge = 0;       // çƒåˆ°è¾¾ HUB è¾¹ç¼˜æ—¶çš„é«˜åº¦
        let isDescending = false;   // çƒæ˜¯å¦åœ¨ä¸‹é™é˜¶æ®µ
        let isSteepEnough = false;  // ä¸‹è½è§’åº¦æ˜¯å¦è¶³å¤Ÿé™¡
        let entryAngleDeg = 0;      // ä¸‹è½è§’åº¦ï¼ˆåº¦ï¼‰

        for (let iter = 0; iter < 3; iter++) {
          // 3.1: è®¡ç®—æœ‰æ•ˆå°„ç¨‹ (å¦‚æœå¯ç”¨ shoot-on-move)
        if (shootOnMove && timeOfFlight > 0) {
          effectiveShotSpeed = range / timeOfFlight - radialV;
          if (effectiveShotSpeed < 0.1) effectiveShotSpeed = 0.1;
          effectiveRange = timeOfFlight * Math.hypot(tangentialV, effectiveShotSpeed);
        } else {
          effectiveShotSpeed = range / timeOfFlight;
          effectiveRange = range;
        }

          // 3.2: æ‰¾åˆ°æœ€ä¼˜ Hood è§’åº¦ï¼ˆå¸¦è¾¹ç¼˜é«˜åº¦+ä¸‹é™+è§’åº¦çº¦æŸï¼‰
          const hoodResult = findOptimalHoodAngle(effectiveRange, deltaH, targetHeight);
          hoodAngle = hoodResult.angle;
          flywheelSpeed = hoodResult.speed;
          clearsHub = hoodResult.clearsHub;
          heightAtEdge = hoodResult.heightAtEdge;
          isDescending = hoodResult.isDescending;
          isSteepEnough = hoodResult.isSteepEnough;
          entryAngleDeg = hoodResult.entryAngleDeg;
          timeOfFlight = hoodResult.timeOfFlight;
          isValid = hoodResult.isValid && Number.isFinite(flywheelSpeed) && flywheelSpeed > 0;

          if (!isValid || !Number.isFinite(timeOfFlight)) {
            isValid = false;
            break;
          }
        }

        // Step 4: è®¡ç®— Yaw è¡¥å¿
        let yawCompensation = 0;
        if (shootOnMove && effectiveShotSpeed > 0.1) {
          yawCompensation = Math.atan2(-tangentialV, effectiveShotSpeed);
        }
        const chassisHeading = goalAngle + yawCompensation;

        // Step 5: è®¡ç®—è™šæ‹Ÿç›®æ ‡ä½ç½® (ç”¨äºå¯è§†åŒ–)
        const virtualTarget = {
          x: targetX - robotVx * timeOfFlight * (shootOnMove ? 1 : 0),
          y: targetY - robotVy * timeOfFlight * (shootOnMove ? 1 : 0),
        };

        // Step 6: è®¡ç®—å®é™…è½ç‚¹
        // çƒçš„åˆé€Ÿåº¦ (åœ°é¢ç³») = flywheel æ–¹å‘é€Ÿåº¦ + æœºå™¨äººé€Ÿåº¦
        const vz = flywheelSpeed * Math.sin(hoodAngle);
        const vHorizontal = flywheelSpeed * Math.cos(hoodAngle);

        // flywheel æ–¹å‘æ˜¯ chassisHeading
        const flywheelVx = vHorizontal * Math.cos(chassisHeading);
        const flywheelVy = vHorizontal * Math.sin(chassisHeading);

        // çƒçš„åœ°é¢é€Ÿåº¦
        const ballVx = flywheelVx + robotVx;
        const ballVy = flywheelVy + robotVy;
        const ballSpeedHorizontal = Math.hypot(ballVx, ballVy);

        let impactPoint = { x: targetX, y: targetY };
        let actualToF = timeOfFlight;

        if (isValid && ballSpeedHorizontal > 0.01) {
          const flight = simulateShotToHeight(ballSpeedHorizontal, vz, deltaH);
          if (flight.reached) {
            actualToF = flight.time;
            const dirX = ballVx / ballSpeedHorizontal;
            const dirY = ballVy / ballSpeedHorizontal;
            impactPoint = {
              x: launcherX + dirX * flight.x,
              y: launcherY + dirY * flight.x,
            };
          } else {
            isValid = false;
          }
        } else {
          isValid = false;
        }

        // æœ€ç»ˆåˆ¤å®šï¼šå¿…é¡»æœ‰æ•ˆ + é¡¶ç‚¹å¤Ÿé«˜ + ä¸‹é™ + è§’åº¦å¤Ÿé™¡ + è½å…¥ç›®æ ‡åŒºåŸŸ
        const hubHexPoints = getHubHexPoints(SCORING_OPENING_SIZE, targetX, targetY);
        const inTarget = pointInPolygon(impactPoint, hubHexPoints);
        const isOnTarget = isValid && clearsHub && isDescending && isSteepEnough && inTarget;

        return {
          chassisHeading,
          flywheelSpeed,
          hoodAngle,
          hoodAngleDeg: hoodAngle * 180 / Math.PI,
          range,
          effectiveRange,
          timeOfFlight: actualToF,
          yawCompensation,
          yawCompensationDeg: yawCompensation * 180 / Math.PI,
          virtualTarget,
          impactPoint,
          isValid,
          clearsHub,       // çƒæ˜¯å¦èƒ½è¶Šè¿‡ HUB è¾¹ç¼˜
          heightAtEdge,    // çƒåˆ°è¾¾ HUB è¾¹ç¼˜æ—¶çš„é«˜åº¦ (m)
          isDescending,    // çƒæ˜¯å¦åœ¨ä¸‹é™é˜¶æ®µ
          isSteepEnough,   // ä¸‹è½è§’åº¦æ˜¯å¦è¶³å¤Ÿé™¡
          entryAngleDeg,   // ä¸‹è½è§’åº¦ï¼ˆåº¦ï¼‰
          inTarget,        // è½ç‚¹æ˜¯å¦åœ¨ HUB å¼€å£å†…
          isOnTarget,      // ç»¼åˆåˆ¤å®š
          goalAngle,
          launcherX,
          launcherY,
          launcherZ: state.launcherHeight + launcherOffset.z,
          // è½¨è¿¹ç»˜åˆ¶ç”¨
          ballVx, ballVy, vz,
        };
      }

      // ===== Three.js åœºæ™¯è®¾ç½® =====
      const container = document.getElementById('canvas-container');
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x16213e);

      const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 100);
      camera.position.set(-1, 6, 4.035);
      camera.lookAt(DEFAULT_TARGET_X, 1.5, DEFAULT_TARGET_Y);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.physicallyCorrectLights = false;
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.NoToneMapping;
      container.appendChild(renderer.domElement);

      const orbitControls = new OrbitControls(camera, renderer.domElement);
      orbitControls.target.set(DEFAULT_TARGET_X, 1, DEFAULT_TARGET_Y);
      orbitControls.enableDamping = true;
      orbitControls.dampingFactor = 0.05;
      orbitControls.update();
      let lastTargetX = state.targetX;
      let lastTargetY = state.targetY;

      // å…‰ç…§
      scene.add(new THREE.AmbientLight(0xffffff, 0.5));
      scene.add(new THREE.HemisphereLight(0xffffff, 0x2c3e50, 0.5));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(10, 20, 10);
      dirLight.castShadow = true;
      scene.add(dirLight);

      // åœºåœ°æ¨¡å‹
      const fieldGroup = new THREE.Group();
      scene.add(fieldGroup);

      const gltfLoader = new GLTFLoader();
      const robotConfigPromise = fetch("assets/Robot_2026FRCKitBotV1/config.json")
        .then((res) => (res.ok ? res.json() : null))
        .catch(() => null);
      const fallbackRobotConfig = {
        rotations: [
          { axis: "x", degrees: 90 },
          { axis: "z", degrees: 90 },
        ],
        position: [-0.3, 0, 0.05],
      };

      function applyConfigRotations(object, rotations) {
        if (!Array.isArray(rotations)) return;
        rotations.forEach((rot) => {
          const axis = rot.axis;
          const radians = THREE.MathUtils.degToRad(rot.degrees || 0);
          if (axis === "x") object.rotateX(radians);
          if (axis === "y") object.rotateY(radians);
          if (axis === "z") object.rotateZ(radians);
        });
      }

      function simplifyMaterial(material) {
        const lambert = new THREE.MeshLambertMaterial({
          color: material?.color ? material.color.clone() : new THREE.Color(0xffffff),
          map: material?.map || null,
          transparent: material?.transparent || false,
          opacity: material?.opacity ?? 1,
          side: material?.side ?? THREE.FrontSide,
        });
        if (material?.emissive) lambert.emissive.copy(material.emissive);
        if (material?.emissiveMap) lambert.emissiveMap = material.emissiveMap;
        if (typeof material?.alphaTest === "number") lambert.alphaTest = material.alphaTest;
        lambert.depthWrite = material?.depthWrite ?? true;
        lambert.depthTest = material?.depthTest ?? true;
        return lambert;
      }

      function simplifyMeshMaterials(mesh) {
        if (Array.isArray(mesh.material)) {
          mesh.material = mesh.material.map((mat) => simplifyMaterial(mat));
        } else if (mesh.material) {
          mesh.material = simplifyMaterial(mesh.material);
        }
      }

      gltfLoader.load(
        "assets/Field3d_2026FRCFieldV1/model.glb",
        (gltf) => {
          const model = gltf.scene;
          model.rotation.set(0, 0, 0);

          const initialBox = new THREE.Box3().setFromObject(model);
          const initialSize = new THREE.Vector3();
          initialBox.getSize(initialSize);

          const axes = [
            { axis: 0, size: initialSize.x },
            { axis: 1, size: initialSize.y },
            { axis: 2, size: initialSize.z },
          ].sort((a, b) => b.size - a.size);

          const lengthAxis = axes[0].axis;
          const widthAxis = axes[1].axis;
          const heightAxis = axes[2].axis;

          const basis = [null, null, null];
          basis[lengthAxis] = new THREE.Vector3(1, 0, 0);
          basis[widthAxis] = new THREE.Vector3(0, 0, 1);
          basis[heightAxis] = new THREE.Vector3(0, 1, 0);

          const rotMatrix = new THREE.Matrix4().makeBasis(basis[0], basis[1], basis[2]);
          if (rotMatrix.determinant() < 0) {
            basis[widthAxis].multiplyScalar(-1);
            rotMatrix.makeBasis(basis[0], basis[1], basis[2]);
          }
          model.setRotationFromMatrix(rotMatrix);

          const box = new THREE.Box3().setFromObject(model);
          const size = new THREE.Vector3();
          box.getSize(size);

          const scaleX = FIELD_LENGTH / size.x;
          const scaleZ = FIELD_WIDTH / size.z;
          const scale = Math.min(scaleX, scaleZ);
          model.scale.setScalar(scale);

          const scaledBox = new THREE.Box3().setFromObject(model);
          model.position.set(
            model.position.x - scaledBox.min.x,
            model.position.y - scaledBox.min.y,
            model.position.z - scaledBox.min.z
          );

          model.traverse((child) => {
            if (child.isMesh) {
              simplifyMeshMaterials(child);
              child.castShadow = false;
              child.receiveShadow = true;
            }
          });

          fieldGroup.add(model);
        },
        undefined,
        (error) => {
          console.warn("Failed to load field model", error);
        }
      );

      // ç‡ƒæ–™æ¨¡å‹
      let fuelTemplate = null;
      gltfLoader.load(
        "assets/Field3d_2026FRCFieldV1/model_0.glb",
        (gltf) => {
          const model = gltf.scene;
          const box = new THREE.Box3().setFromObject(model);
          const size = new THREE.Vector3();
          box.getSize(size);
          const maxDim = Math.max(size.x, size.y, size.z);
          const scale = maxDim > 0 ? BALL_DIAMETER / maxDim : 1;
          model.scale.setScalar(scale);
          const scaledBox = new THREE.Box3().setFromObject(model);
          const center = new THREE.Vector3();
          scaledBox.getCenter(center);
          model.position.sub(center);
          model.traverse((child) => {
            if (child.isMesh) {
              simplifyMeshMaterials(child);
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          fuelTemplate = model;
        },
        undefined,
        (error) => {
          console.warn("Failed to load fuel model", error);
        }
      );

      // æœºå™¨äºº
      const ROBOT_HEADING_OFFSET = 0;
      const ROBOT_MODEL_YAW_OFFSET = 0;
      const ROBOT_MODEL_PITCH_OFFSET = -Math.PI / 2;
      const ROBOT_MODEL_ROLL_OFFSET = 0;
      const robotGroup = new THREE.Group();
      const robotVisual = new THREE.Group();
      robotGroup.add(robotVisual);
      scene.add(robotGroup);
      robotVisual.rotation.y = ROBOT_MODEL_YAW_OFFSET;

      gltfLoader.load(
        "assets/Robot_2026FRCKitBotV1/model.glb",
        (gltf) => {
          const model = gltf.scene;
          robotConfigPromise.then((config) => {
            const resolvedConfig = config || fallbackRobotConfig;
            model.rotation.set(0, 0, 0);
            applyConfigRotations(model, resolvedConfig.rotations);
            model.rotateX(ROBOT_MODEL_PITCH_OFFSET);
            model.rotateZ(ROBOT_MODEL_ROLL_OFFSET);

            const box = new THREE.Box3().setFromObject(model);
            const center = new THREE.Vector3();
            box.getCenter(center);
            model.position.x -= center.x;
            model.position.z -= center.z;
            model.position.y -= box.min.y;

            if (Array.isArray(resolvedConfig.position)) {
              model.position.x += resolvedConfig.position[0] || 0;
              model.position.y += resolvedConfig.position[1] || 0;
              model.position.z += resolvedConfig.position[2] || 0;
            }

            model.traverse((child) => {
              if (child.isMesh) {
                simplifyMeshMaterials(child);
                child.castShadow = true;
                child.receiveShadow = true;
              }
            });

            robotVisual.add(model);
          });
        },
        undefined,
        (error) => {
          console.warn("Failed to load robot model", error);
        }
      );

      // æ–¹å‘ç®­å¤´
      const arrowShape = new THREE.Shape();
      arrowShape.moveTo(0.25, 0);
      arrowShape.lineTo(-0.1, -0.12);
      arrowShape.lineTo(-0.1, 0.12);
      arrowShape.closePath();
      const arrowGeo = new THREE.ShapeGeometry(arrowShape);
      const arrowMat = new THREE.MeshBasicMaterial({ color: 0xee6c4d, side: THREE.DoubleSide });
      const directionArrow = new THREE.Mesh(arrowGeo, arrowMat);
      directionArrow.rotation.x = -Math.PI / 2;
      directionArrow.position.y = 0.35;
      robotGroup.add(directionArrow);

      // é€Ÿåº¦ç®­å¤´
      const velocityArrow = new THREE.ArrowHelper(
        new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), 1, 0x2a9d8f, 0.15, 0.1
      );
      scene.add(velocityArrow);

      // é™æ­¢å‚è€ƒçº¿
      const refLineMat = new THREE.LineDashedMaterial({ color: 0x666666, dashSize: 0.15, gapSize: 0.1, transparent: true, opacity: 0.5 });
      const refLineGeo = new THREE.BufferGeometry();
      const refLine = new THREE.Line(refLineGeo, refLineMat);
      scene.add(refLine);

      // ç„å‡†çº¿
      const aimLineMat = new THREE.LineBasicMaterial({ color: 0xee6c4d, transparent: true, opacity: 0.8 });
      const aimLineGeo = new THREE.BufferGeometry();
      const aimLine = new THREE.Line(aimLineGeo, aimLineMat);
      scene.add(aimLine);

      // è™šæ‹Ÿç›®æ ‡
      const vtGeo = new THREE.RingGeometry(0.08, 0.12, 32);
      const vtMat = new THREE.MeshBasicMaterial({ color: 0xffb703, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
      const vtMesh = new THREE.Mesh(vtGeo, vtMat);
      vtMesh.rotation.x = -Math.PI / 2;
      scene.add(vtMesh);

      // è™šæ‹Ÿç›®æ ‡å‚ç›´çº¿
      const vtLineMat = new THREE.LineDashedMaterial({ color: 0xffb703, dashSize: 0.1, gapSize: 0.05, transparent: true, opacity: 0.5 });
      const vtLineGeo = new THREE.BufferGeometry();
      const vtLine = new THREE.Line(vtLineGeo, vtLineMat);
      scene.add(vtLine);

      // ç›®æ ‡å°„å‡»ç‚¹
      const targetMarkerGeo = new THREE.RingGeometry(0.14, 0.2, 32);
      const targetMarkerMat = new THREE.MeshBasicMaterial({
        color: 0x00b4d8,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.7
      });
      const targetMarker = new THREE.Mesh(targetMarkerGeo, targetMarkerMat);
      targetMarker.rotation.x = -Math.PI / 2;
      scene.add(targetMarker);

      // è½ç‚¹
      const impactGeo = new THREE.SphereGeometry(BALL_RADIUS, 16, 16);
      const impactMat = new THREE.MeshBasicMaterial({ color: 0x2a9d8f, transparent: true, opacity: 0.9 });
      const impactMesh = new THREE.Mesh(impactGeo, impactMat);
      scene.add(impactMesh);

      // è¿ç»­å°„çƒ
      const shotsGroup = new THREE.Group();
      scene.add(shotsGroup);
      const shotGeo = new THREE.SphereGeometry(BALL_RADIUS, 16, 16);
      const baseShotMaterial = new THREE.MeshLambertMaterial({
        color: 0xffb703,
        transparent: true,
        opacity: 0.9
      });

      const shots = [];
      let shotTimer = 0;

      function buildFuelShot() {
        if (!fuelTemplate) {
          const mesh = new THREE.Mesh(shotGeo, baseShotMaterial.clone());
          return { object: mesh, materials: [mesh.material] };
        }

        const shot = fuelTemplate.clone(true);
        const materials = [];
        shot.traverse((child) => {
          if (child.isMesh) {
            child.material = child.material.clone();
            child.material.transparent = true;
            child.castShadow = true;
            child.receiveShadow = true;
            materials.push(child.material);
          }
        });
        return { object: shot, materials };
      }

      function spawnShot(solution) {
        const shotData = buildFuelShot();
        const shot = shotData.object;
        const x = solution.launcherX;
        const y = solution.launcherY;
        const z = solution.launcherZ;
        shot.position.set(x, z, y);
        shotsGroup.add(shot);

        shots.push({
          object: shot,
          materials: shotData.materials,
          x,
          y,
          z,
          vx: solution.ballVx,
          vy: solution.ballVy,
          vz: solution.vz,
          age: 0
        });

        if (shots.length > MAX_SHOTS) {
          const old = shots.shift();
          shotsGroup.remove(old.object);
          old.materials.forEach((mat) => mat.dispose());
        }
      }

      function updateShots(dt, solution) {
        const targetHeight = getTargetHeight();
        if (solution && solution.isValid) {
          shotTimer += dt;
          if (shotTimer >= SHOT_INTERVAL) {
            spawnShot(solution);
            shotTimer = 0;
          }
        } else {
          shotTimer = 0;
        }

        for (let i = shots.length - 1; i >= 0; i--) {
          const shot = shots[i];
          shot.age += dt;

          const speed = Math.hypot(shot.vx, shot.vy, shot.vz);
          const ax = -DRAG_K * speed * shot.vx;
          const ay = -DRAG_K * speed * shot.vy;
          const az = -GRAVITY - DRAG_K * speed * shot.vz;

          shot.vx += ax * dt;
          shot.vy += ay * dt;
          shot.vz += az * dt;

          shot.x += shot.vx * dt;
          shot.y += shot.vy * dt;
          shot.z += shot.vz * dt;

          shot.object.position.set(shot.x, shot.z, shot.y);
          const opacity = Math.max(0, 0.95 - shot.age / SHOT_LIFETIME);
          shot.materials.forEach((mat) => {
            mat.opacity = opacity;
          });

          if ((shot.vz < 0 && shot.z <= targetHeight) || shot.z < BALL_RADIUS || shot.age > SHOT_LIFETIME) {
            shotsGroup.remove(shot.object);
            shot.materials.forEach((mat) => mat.dispose());
            shots.splice(i, 1);
          }
        }
      }

      // å¼¹é“è½¨è¿¹
      let trajectoryLine = null;

      function updateTrajectory(solution) {
        if (trajectoryLine) {
          scene.remove(trajectoryLine);
          trajectoryLine.geometry.dispose();
          trajectoryLine = null;
        }

        if (!solution.isValid) return;

        const points = [];
        const { ballVx, ballVy, vz } = solution;
        let x = solution.launcherX;
        let y = solution.launcherY;
        let z = solution.launcherZ;
        let vx = ballVx;
        let vy = ballVy;
        let vzCurr = vz;
        const targetHeight = getTargetHeight();

        for (let t = 0; t < TRAJ_MAX_TIME; t += TRAJ_DT) {
          points.push(new THREE.Vector3(x, z, y));

          const prevX = x;
          const prevY = y;
          const prevZ = z;

          const speed = Math.hypot(vx, vy, vzCurr);
          const ax = -DRAG_K * speed * vx;
          const ay = -DRAG_K * speed * vy;
          const az = -GRAVITY - DRAG_K * speed * vzCurr;

          vx += ax * TRAJ_DT;
          vy += ay * TRAJ_DT;
          vzCurr += az * TRAJ_DT;

          x += vx * TRAJ_DT;
          y += vy * TRAJ_DT;
          z += vzCurr * TRAJ_DT;

          if (vzCurr < 0 && z <= targetHeight) {
            const dz = z - prevZ;
            const ratio = dz !== 0 ? (targetHeight - prevZ) / dz : 0;
            const ix = prevX + (x - prevX) * ratio;
            const iy = prevY + (y - prevY) * ratio;
            points.push(new THREE.Vector3(ix, targetHeight, iy));
            break;
          }

          if (z < BALL_RADIUS) break;
        }

        if (points.length < 2) return;

        const trajGeo = new THREE.BufferGeometry().setFromPoints(points);
        const trajMat = new THREE.LineBasicMaterial({ color: 0xee6c4d, transparent: true, opacity: 0.8 });
        trajectoryLine = new THREE.Line(trajGeo, trajMat);
        scene.add(trajectoryLine);
      }

      // ===== åœºæ™¯æ›´æ–°å‡½æ•° =====
      function updateScene(solution) {
        const targetHeight = getTargetHeight();

        if (state.targetX !== lastTargetX || state.targetY !== lastTargetY) {
          orbitControls.target.set(state.targetX, 1, state.targetY);
          lastTargetX = state.targetX;
          lastTargetY = state.targetY;
        }

        // æ›´æ–°æŒ‡æ ‡
        metrics.range.textContent = solution.range.toFixed(2);
        metrics.flywheel.textContent = solution.isValid ? solution.flywheelSpeed.toFixed(1) : "---";
        metrics.hood.textContent = solution.isValid ? solution.hoodAngleDeg.toFixed(1) : "---";
        metrics.entry.textContent = solution.isValid && solution.isDescending ? solution.entryAngleDeg.toFixed(1) : "---";

        const isOk = solution.isOnTarget;
        metrics.onTarget.textContent = isOk ? "æ˜¯" : "å¦";
        metrics.onTarget.classList.toggle("ok", isOk);
        metrics.onTarget.classList.toggle("warn", !isOk);

        // æœºå™¨äººä½ç½®å’Œæœå‘
        robotGroup.position.set(state.robotX, 0, state.robotY);
        robotGroup.rotation.y = -state.chassisHeading + ROBOT_HEADING_OFFSET;

        // é€Ÿåº¦ç®­å¤´
        const speed = Math.hypot(state.robotVx, state.robotVy);
        if (speed > 0.01) {
          velocityArrow.visible = true;
          velocityArrow.position.set(state.robotX, 0.3, state.robotY);
          velocityArrow.setDirection(new THREE.Vector3(state.robotVx, 0, state.robotVy).normalize());
          velocityArrow.setLength(Math.min(speed * 2, 3), 0.15, 0.1);
        } else {
          velocityArrow.visible = false;
        }

        // é™æ­¢å‚è€ƒçº¿
        refLineGeo.setFromPoints([
          new THREE.Vector3(solution.launcherX, solution.launcherZ, solution.launcherY),
          new THREE.Vector3(state.targetX, targetHeight, state.targetY),
        ]);
        refLine.computeLineDistances();

        // ç„å‡†çº¿
        aimLineGeo.setFromPoints([
          new THREE.Vector3(solution.launcherX, solution.launcherZ, solution.launcherY),
          new THREE.Vector3(state.targetX, targetHeight, state.targetY),
        ]);

        // è™šæ‹Ÿç›®æ ‡
        vtMesh.position.set(solution.virtualTarget.x, 0.02, solution.virtualTarget.y);
        vtLineGeo.setFromPoints([
          new THREE.Vector3(solution.virtualTarget.x, 0.02, solution.virtualTarget.y),
          new THREE.Vector3(solution.virtualTarget.x, targetHeight, solution.virtualTarget.y),
        ]);
        vtLine.computeLineDistances();

        // ç›®æ ‡å°„å‡»ç‚¹
        targetMarker.position.set(state.targetX, targetHeight, state.targetY);

        // è½ç‚¹
        impactMesh.position.set(solution.impactPoint.x, targetHeight, solution.impactPoint.y);
        impactMat.color.setHex(solution.isOnTarget ? 0x2a9d8f : 0xc1121f);

        // å¼¹é“è½¨è¿¹
        updateTrajectory(solution);
      }

      // ===== UI æ§ä»¶ç»‘å®š =====
      const controlMap = {};
      document.querySelectorAll(".control-row").forEach((row) => {
        const key = row.dataset.key;
        const range = row.querySelector('input[type="range"]');
        const number = row.querySelector('input[type="number"]');
        controlMap[key] = { range, number };

        const update = (value) => {
          const parsed = Number(value);
          if (Number.isNaN(parsed)) return;
          state[key] = parsed;
          range.value = parsed;
          number.value = parsed.toFixed(2);
        };

        range.addEventListener("input", (e) => update(e.target.value));
        number.addEventListener("input", (e) => update(e.target.value));
      });

      function updateControl(key, value) {
        const control = controlMap[key];
        if (!control) return;
        control.range.value = value;
        control.number.value = value.toFixed(2);
      }

      function setControlValue(key, value) {
        state[key] = value;
        updateControl(key, value);
      }

      document.getElementById("shootOnMove").addEventListener("change", (e) => {
        state.shootOnMove = e.target.checked;
      });

      document.getElementById("resetTarget").addEventListener("click", () => {
        setControlValue("targetX", DEFAULT_TARGET_X);
        setControlValue("targetY", DEFAULT_TARGET_Y);
        setControlValue("targetZ", DEFAULT_TARGET_HEIGHT);
      });

      // ===== é”®ç›˜æ§åˆ¶ =====
      container.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        if (key in keys) {
          keys[key] = true;
          e.preventDefault();
        }
        if (key === ' ') {
          state.robotVx = 0;
          state.robotVy = 0;
          e.preventDefault();
        }
      });

      container.addEventListener('keyup', (e) => {
        const key = e.key.toLowerCase();
        if (key in keys) {
          keys[key] = false;
          e.preventDefault();
        }
      });

      container.addEventListener('click', () => container.focus());

      // ===== æ¸¸æˆå¾ªç¯ =====
      let lastTime = performance.now();
      const SOLVER_INTERVAL = 1 / 30;
      let solverAccumulator = 0;
      let cachedSolution = null;

      function gameLoop() {
        const now = performance.now();
        const dt = (now - lastTime) / 1000;
        lastTime = now;

        // WASD æ§åˆ¶
        let targetVx = 0, targetVy = 0;
        if (keys.w) targetVx += 1;
        if (keys.s) targetVx -= 1;
        if (keys.a) targetVy -= 1;
        if (keys.d) targetVy += 1;

        const targetDirLen = Math.hypot(targetVx, targetVy);
        if (targetDirLen > 0.01) {
          targetVx /= targetDirLen;
          targetVy /= targetDirLen;
        }

        const desiredVx = targetVx * state.maxLinearSpeed;
        const desiredVy = targetVy * state.maxLinearSpeed;

        // åŠ é€Ÿåº¦é™åˆ¶
        const dvx = desiredVx - state.robotVx;
        const dvy = desiredVy - state.robotVy;
        const accelNeeded = Math.hypot(dvx, dvy) / dt;

        if (accelNeeded > state.maxAcceleration) {
          const scale = (state.maxAcceleration * dt) / Math.hypot(dvx, dvy);
          state.robotVx += dvx * scale;
          state.robotVy += dvy * scale;
        } else {
          state.robotVx = desiredVx;
          state.robotVy = desiredVy;
        }

        // é€Ÿåº¦é™åˆ¶
        const currentSpeed = Math.hypot(state.robotVx, state.robotVy);
        if (currentSpeed > state.maxLinearSpeed) {
          const scale = state.maxLinearSpeed / currentSpeed;
          state.robotVx *= scale;
          state.robotVy *= scale;
        }

        // æ›´æ–°ä½ç½®
        state.robotX += state.robotVx * dt;
        state.robotY += state.robotVy * dt;

        // è¾¹ç•Œ
        state.robotX = Math.max(0.3, Math.min(FIELD_LENGTH - 0.3, state.robotX));
        state.robotY = Math.max(0.3, Math.min(FIELD_WIDTH - 0.3, state.robotY));

        // è®¡ç®—å°„çƒè§£å†³æ–¹æ¡ˆ
        solverAccumulator += dt;
        if (!cachedSolution || solverAccumulator >= SOLVER_INTERVAL) {
          cachedSolution = computeShootingSolution();
          solverAccumulator = 0;
        }
        const solution = cachedSolution;

        // è‡ªåŠ¨è¿½è¸ªï¼šåº•ç›˜æœå‘è·Ÿéš chassisHeading
        const targetHeading = solution.chassisHeading;
        let headingError = targetHeading - state.chassisHeading;
        while (headingError > Math.PI) headingError -= Math.PI * 2;
        while (headingError < -Math.PI) headingError += Math.PI * 2;

        const MAX_OMEGA = 6.0;
        const OMEGA_GAIN = 4.0;
        const omega = Math.max(-MAX_OMEGA, Math.min(MAX_OMEGA, headingError * OMEGA_GAIN));
        state.chassisHeading += omega * dt;

        // æ›´æ–°æ§ä»¶æ˜¾ç¤º
        updateControl("robotX", state.robotX);
        updateControl("robotY", state.robotY);

        updateScene(solution);
        updateShots(dt, solution);
      }

      // ===== åŠ¨ç”»å¾ªç¯ =====
      function animate() {
        requestAnimationFrame(animate);
        gameLoop();
        orbitControls.update();
        renderer.render(scene, camera);
      }

      // ===== çª—å£è°ƒæ•´ =====
      window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });

      // ===== å¯åŠ¨ =====
      container.focus();
      animate();
    </script>
  </body>
</html>
